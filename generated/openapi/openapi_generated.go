//go:build !ignore_autogenerated
// +build !ignore_autogenerated

/*
  Copyright The Kubernetes Authors.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/

// Code generated by openapi-gen. DO NOT EDIT.

package openapi

import (
	common "k8s.io/kube-openapi/pkg/common"
	spec "k8s.io/kube-openapi/pkg/validation/spec"
)

func GetOpenAPIDefinitions(ref common.ReferenceCallback) map[string]common.OpenAPIDefinition {
	return map[string]common.OpenAPIDefinition{
		"github.com/srl-labs/clabernetes/apis/v1alpha1.Config":                schema_srl_labs_clabernetes_apis_v1alpha1_Config(ref),
		"github.com/srl-labs/clabernetes/apis/v1alpha1.ConfigDeployment":      schema_srl_labs_clabernetes_apis_v1alpha1_ConfigDeployment(ref),
		"github.com/srl-labs/clabernetes/apis/v1alpha1.ConfigImagePull":       schema_srl_labs_clabernetes_apis_v1alpha1_ConfigImagePull(ref),
		"github.com/srl-labs/clabernetes/apis/v1alpha1.ConfigList":            schema_srl_labs_clabernetes_apis_v1alpha1_ConfigList(ref),
		"github.com/srl-labs/clabernetes/apis/v1alpha1.ConfigMetadata":        schema_srl_labs_clabernetes_apis_v1alpha1_ConfigMetadata(ref),
		"github.com/srl-labs/clabernetes/apis/v1alpha1.ConfigSpec":            schema_srl_labs_clabernetes_apis_v1alpha1_ConfigSpec(ref),
		"github.com/srl-labs/clabernetes/apis/v1alpha1.ConfigStatus":          schema_srl_labs_clabernetes_apis_v1alpha1_ConfigStatus(ref),
		"github.com/srl-labs/clabernetes/apis/v1alpha1.Connectivity":          schema_srl_labs_clabernetes_apis_v1alpha1_Connectivity(ref),
		"github.com/srl-labs/clabernetes/apis/v1alpha1.ConnectivityList":      schema_srl_labs_clabernetes_apis_v1alpha1_ConnectivityList(ref),
		"github.com/srl-labs/clabernetes/apis/v1alpha1.ConnectivitySpec":      schema_srl_labs_clabernetes_apis_v1alpha1_ConnectivitySpec(ref),
		"github.com/srl-labs/clabernetes/apis/v1alpha1.ConnectivityStatus":    schema_srl_labs_clabernetes_apis_v1alpha1_ConnectivityStatus(ref),
		"github.com/srl-labs/clabernetes/apis/v1alpha1.Definition":            schema_srl_labs_clabernetes_apis_v1alpha1_Definition(ref),
		"github.com/srl-labs/clabernetes/apis/v1alpha1.Deployment":            schema_srl_labs_clabernetes_apis_v1alpha1_Deployment(ref),
		"github.com/srl-labs/clabernetes/apis/v1alpha1.Expose":                schema_srl_labs_clabernetes_apis_v1alpha1_Expose(ref),
		"github.com/srl-labs/clabernetes/apis/v1alpha1.ExposedPorts":          schema_srl_labs_clabernetes_apis_v1alpha1_ExposedPorts(ref),
		"github.com/srl-labs/clabernetes/apis/v1alpha1.FileFromConfigMap":     schema_srl_labs_clabernetes_apis_v1alpha1_FileFromConfigMap(ref),
		"github.com/srl-labs/clabernetes/apis/v1alpha1.FileFromURL":           schema_srl_labs_clabernetes_apis_v1alpha1_FileFromURL(ref),
		"github.com/srl-labs/clabernetes/apis/v1alpha1.ImagePull":             schema_srl_labs_clabernetes_apis_v1alpha1_ImagePull(ref),
		"github.com/srl-labs/clabernetes/apis/v1alpha1.ImageRequest":          schema_srl_labs_clabernetes_apis_v1alpha1_ImageRequest(ref),
		"github.com/srl-labs/clabernetes/apis/v1alpha1.ImageRequestList":      schema_srl_labs_clabernetes_apis_v1alpha1_ImageRequestList(ref),
		"github.com/srl-labs/clabernetes/apis/v1alpha1.ImageRequestSpec":      schema_srl_labs_clabernetes_apis_v1alpha1_ImageRequestSpec(ref),
		"github.com/srl-labs/clabernetes/apis/v1alpha1.ImageRequestStatus":    schema_srl_labs_clabernetes_apis_v1alpha1_ImageRequestStatus(ref),
		"github.com/srl-labs/clabernetes/apis/v1alpha1.LinkEndpoint":          schema_srl_labs_clabernetes_apis_v1alpha1_LinkEndpoint(ref),
		"github.com/srl-labs/clabernetes/apis/v1alpha1.Persistence":           schema_srl_labs_clabernetes_apis_v1alpha1_Persistence(ref),
		"github.com/srl-labs/clabernetes/apis/v1alpha1.PointToPointTunnel":    schema_srl_labs_clabernetes_apis_v1alpha1_PointToPointTunnel(ref),
		"github.com/srl-labs/clabernetes/apis/v1alpha1.ProbeConfiguration":    schema_srl_labs_clabernetes_apis_v1alpha1_ProbeConfiguration(ref),
		"github.com/srl-labs/clabernetes/apis/v1alpha1.ReconcileHashes":       schema_srl_labs_clabernetes_apis_v1alpha1_ReconcileHashes(ref),
		"github.com/srl-labs/clabernetes/apis/v1alpha1.SSHProbeConfiguration": schema_srl_labs_clabernetes_apis_v1alpha1_SSHProbeConfiguration(ref),
		"github.com/srl-labs/clabernetes/apis/v1alpha1.Scheduling":            schema_srl_labs_clabernetes_apis_v1alpha1_Scheduling(ref),
		"github.com/srl-labs/clabernetes/apis/v1alpha1.StatusProbes":          schema_srl_labs_clabernetes_apis_v1alpha1_StatusProbes(ref),
		"github.com/srl-labs/clabernetes/apis/v1alpha1.TCPProbeConfiguration": schema_srl_labs_clabernetes_apis_v1alpha1_TCPProbeConfiguration(ref),
		"github.com/srl-labs/clabernetes/apis/v1alpha1.Topology":              schema_srl_labs_clabernetes_apis_v1alpha1_Topology(ref),
		"github.com/srl-labs/clabernetes/apis/v1alpha1.TopologyList":          schema_srl_labs_clabernetes_apis_v1alpha1_TopologyList(ref),
		"github.com/srl-labs/clabernetes/apis/v1alpha1.TopologySpec":          schema_srl_labs_clabernetes_apis_v1alpha1_TopologySpec(ref),
		"github.com/srl-labs/clabernetes/apis/v1alpha1.TopologyStatus":        schema_srl_labs_clabernetes_apis_v1alpha1_TopologyStatus(ref),
	}
}

func schema_srl_labs_clabernetes_apis_v1alpha1_Config(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Config is an object that holds global clabernetes config information. Note that this CR is expected to effectively be a global singleton -- that is, there should be only *one* of these, and it *must* be named `clabernetes` -- CRD metadata spec will enforce this (via x-validation rules).",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/srl-labs/clabernetes/apis/v1alpha1.ConfigSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/srl-labs/clabernetes/apis/v1alpha1.ConfigStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/srl-labs/clabernetes/apis/v1alpha1.ConfigSpec", "github.com/srl-labs/clabernetes/apis/v1alpha1.ConfigStatus", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_srl_labs_clabernetes_apis_v1alpha1_ConfigDeployment(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ConfigDeployment holds \"global\" or \"default\" configurations related to clabernetes spawned deployments. In the future this will likely include more of the \"normal\" (topology-level) deployment configs (ex: persistence, or maybe files from url).",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"resourcesDefault": {
						SchemaProps: spec.SchemaProps{
							Description: "ResourcesDefault is the default set of resources for clabernetes launcher pods. This is used only as a last option if a Topology does not have resources, and there are no resources for the given containerlab kind/type",
							Ref:         ref("k8s.io/api/core/v1.ResourceRequirements"),
						},
					},
					"resourcesByContainerlabKind": {
						SchemaProps: spec.SchemaProps{
							Description: "ResourcesByContainerlabKind is a mapping of container lab kind -> type -> default resource settings. Note that a key value of \"default\" in the inner map will apply the given resources for any pod of that containerlab *kind*. For example: {\n  \"srl\": {\n    \"default\": DEFAULT RESOURCES FOR KIND \"srl\",\n    \"ixr10\": RESOURCES FOR KIND \"srl\", TYPE \"ixr10\"\n} Given resources as above, a containerlab node of kind \"srl\" and \"type\" ixr10\" would get the specific resources as allocated in the ixr10 key, whereas a containerlab kind of \"srl\" and \"type\" unset or \"ixr6\" would get the \"default\" resource settings. To apply global default resources, regardless of containerlab kind/type, use the `resourcesDefault` field.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type: []string{"object"},
										AdditionalProperties: &spec.SchemaOrBool{
											Allows: true,
											Schema: &spec.Schema{
												SchemaProps: spec.SchemaProps{
													Ref: ref("k8s.io/api/core/v1.ResourceRequirements"),
												},
											},
										},
									},
								},
							},
						},
					},
					"nodeSelectorsByImage": {
						SchemaProps: spec.SchemaProps{
							Description: "NodeSelectorsByImage is a mapping of image glob pattern as key and node selectors (value) to apply to each deployment. Note that in case of multiple matches, the longest (with most characters) will take precedence. A config example: {\n  \"internal.io/nokia_sros*\": {\"node-flavour\": \"baremetal\"},\n  \"ghcr.io/nokia/srlinux*\":  {\"node-flavour\": \"amd64\"},\n  \"default\":                 {\"node-flavour\": \"cheap\"},\n}.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type: []string{"object"},
										AdditionalProperties: &spec.SchemaOrBool{
											Allows: true,
											Schema: &spec.Schema{
												SchemaProps: spec.SchemaProps{
													Default: "",
													Type:    []string{"string"},
													Format:  "",
												},
											},
										},
									},
								},
							},
						},
					},
					"privilegedLauncher": {
						SchemaProps: spec.SchemaProps{
							Description: "PrivilegedLauncher, when true, sets the launcher containers to privileged. By default, we do our best to *not* need this/set this, and instead set only the capabilities we need, however its possible that some containers launched by the launcher may need/want more capabilities, so this flag exists for users to bypass the default settings and enable fully privileged launcher pods.",
							Default:     false,
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"containerlabDebug": {
						SchemaProps: spec.SchemaProps{
							Description: "ContainerlabDebug sets the `--debug` flag when invoking containerlab in the launcher pods. This is disabled by default.",
							Default:     false,
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"containerlabTimeout": {
						SchemaProps: spec.SchemaProps{
							Description: "ContainerlabTimeout sets the `--timeout` flag when invoking containerlab in the launcher pods.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"containerlabVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "ContainerlabVersion sets a custom version to use for containerlab -- when set this will cause the launcher pods to download and use this specific version of containerlab. Setting a bad version (version that doesnt exist/typo/etc.) will cause pods to fail to launch, so be careful! You never \"need\" to this as the publicly available launcher image will always be built with a (reasonably) up to date containerlab version, this setting exists in case you want to pin back to an older version for some reason or you want to be bleeding edge with some new feature (but do note that just because it exists in containerlab doesnt *necessarily* mean it will be auto-working in clabernetes!",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"launcherImage": {
						SchemaProps: spec.SchemaProps{
							Description: "LauncherImage sets the default launcher image to use when spawning launcher deployments.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"launcherImagePullPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "LauncherImagePullPolicy sets the default launcher image pull policy to use when spawning launcher deployments.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"launcherLogLevel": {
						SchemaProps: spec.SchemaProps{
							Description: "LauncherLogLevel sets the launcher clabernetes worker log level -- this overrides whatever is set on the controllers env vars for this topology. Note: omitempty because empty str does not satisfy enum of course.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"extraEnv": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "ExtraEnv is a list of additional environment variables to set on the launcher container. The values here are applied to *all* launchers since this is the global config after all!",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.EnvVar"),
									},
								},
							},
						},
					},
				},
				Required: []string{"launcherImage", "launcherImagePullPolicy"},
			},
		},
		Dependencies: []string{
			"k8s.io/api/core/v1.EnvVar", "k8s.io/api/core/v1.ResourceRequirements"},
	}
}

func schema_srl_labs_clabernetes_apis_v1alpha1_ConfigImagePull(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ConfigImagePull holds configurations relevant to how clabernetes launcher pods handle pulling images.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"pullThroughOverride": {
						SchemaProps: spec.SchemaProps{
							Description: "PullThroughOverride allows for overriding the image pull through mode for this particular topology.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"criSockOverride": {
						SchemaProps: spec.SchemaProps{
							Description: "CRISockOverride allows for overriding the path of the CRI sock that is mounted in the launcher pods (if/when image pull through mode is auto or always). This can be useful if, for example, the CRI sock is in a \"non-standard\" location like K3s which puts the containerd sock at `/run/k3s/containerd/containerd.sock` rather than the \"normal\" (whatever that means) location of `/run/containerd/containerd.sock`. The value must end with \"containerd.sock\" for now, in the future maybe crio support will be added.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"criKindOverride": {
						SchemaProps: spec.SchemaProps{
							Description: "CRIKindOverride allows for overriding the auto discovered cri flavor of the cluster -- this may be useful if we fail to parse the cri kind for some reason, or in mixed cri flavor clusters -- however in the latter case, make sure that if you are using image pull through that clabernetes workloads are only run on the nodes of the cri kind specified here!",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"dockerDaemonConfig": {
						SchemaProps: spec.SchemaProps{
							Description: "DockerDaemonConfig allows for setting a default docker daemon config for launcher pods with the specified secret. The secret *must be present in the namespace of any given topology* -- so if you are configuring this at the \"global config\" level, ensure that you are deploying topologies into a specific namespace, or have ensured there is a secret of the given name in every namespace you wish to deploy a topology to. When set, insecure registries config option is ignored as it is assumed you are handling that in the given docker config. Note that the secret *must* contain a key \"daemon.json\" -- as this secret will be mounted to /etc/docker and docker will be expecting the config at /etc/docker/daemon.json.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"dockerConfig": {
						SchemaProps: spec.SchemaProps{
							Description: "DockerConfig allows for setting the docker user (for root) config for all launchers in this topology. The secret *must be present in the namespace of this topology*. The secret *must* contain a key \"config.json\" -- as this secret will be mounted to /root/.docker/config.json and as such wil be utilized when doing docker-y things -- this means you can put auth things in here in the event your cluster doesn't support the preferred image pull through option.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_srl_labs_clabernetes_apis_v1alpha1_ConfigList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ConfigList is a list of Config objects.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/srl-labs/clabernetes/apis/v1alpha1.Config"),
									},
								},
							},
						},
					},
				},
				Required: []string{"items"},
			},
		},
		Dependencies: []string{
			"github.com/srl-labs/clabernetes/apis/v1alpha1.Config", "k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"},
	}
}

func schema_srl_labs_clabernetes_apis_v1alpha1_ConfigMetadata(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ConfigMetadata holds \"global\" configuration data that will be applied to all objects created by the clabernetes controller.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"annotations": {
						SchemaProps: spec.SchemaProps{
							Description: "Annotations holds key/value pairs that should be set as annotations on clabernetes created resources. Note that (currently?) there is no input validation here, but this data must be valid kubernetes annotation data.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"labels": {
						SchemaProps: spec.SchemaProps{
							Description: "Labels holds key/value pairs that should be set as labels on clabernetes created resources. Note that (currently?) there is no input validation here, but this data must be valid kubernetes label data.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func schema_srl_labs_clabernetes_apis_v1alpha1_ConfigSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ConfigSpec is the spec for a Config resource.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Description: "Metadata holds \"global\" metadata -- that is, metadata that is applied to all objects created by the clabernetes controller.",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/srl-labs/clabernetes/apis/v1alpha1.ConfigMetadata"),
						},
					},
					"inClusterDNSSuffix": {
						SchemaProps: spec.SchemaProps{
							Description: "InClusterDNSSuffix overrides the default in cluster dns suffix used when resolving services.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"imagePull": {
						SchemaProps: spec.SchemaProps{
							Description: "ImagePull holds configurations relevant to how clabernetes launcher pods handle pulling images.",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/srl-labs/clabernetes/apis/v1alpha1.ConfigImagePull"),
						},
					},
					"deployment": {
						SchemaProps: spec.SchemaProps{
							Description: "Deployment holds clabernetes deployment related configuration settings.",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/srl-labs/clabernetes/apis/v1alpha1.ConfigDeployment"),
						},
					},
					"naming": {
						SchemaProps: spec.SchemaProps{
							Description: "Naming holds the global override for the \"naming\" setting for Topology objects -- this controls whether the Topology resources have the containerlab topology name as a prefix. Of course this is ignored if a Topology sets its Naming field to something not \"global\".",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/srl-labs/clabernetes/apis/v1alpha1.ConfigDeployment", "github.com/srl-labs/clabernetes/apis/v1alpha1.ConfigImagePull", "github.com/srl-labs/clabernetes/apis/v1alpha1.ConfigMetadata"},
	}
}

func schema_srl_labs_clabernetes_apis_v1alpha1_ConfigStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ConfigStatus is the status for a Config resource.",
				Type:        []string{"object"},
			},
		},
	}
}

func schema_srl_labs_clabernetes_apis_v1alpha1_Connectivity(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Connectivity is an object that holds information about a connectivity between launcher pods in a clabernetes Topology.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/srl-labs/clabernetes/apis/v1alpha1.ConnectivitySpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/srl-labs/clabernetes/apis/v1alpha1.ConnectivityStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/srl-labs/clabernetes/apis/v1alpha1.ConnectivitySpec", "github.com/srl-labs/clabernetes/apis/v1alpha1.ConnectivityStatus", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_srl_labs_clabernetes_apis_v1alpha1_ConnectivityList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ConnectivityList is a list of Connectivity objects.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/srl-labs/clabernetes/apis/v1alpha1.Connectivity"),
									},
								},
							},
						},
					},
				},
				Required: []string{"items"},
			},
		},
		Dependencies: []string{
			"github.com/srl-labs/clabernetes/apis/v1alpha1.Connectivity", "k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"},
	}
}

func schema_srl_labs_clabernetes_apis_v1alpha1_ConnectivitySpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ConnectivitySpec is the spec for a Connectivity resource.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"pointToPointTunnels": {
						SchemaProps: spec.SchemaProps{
							Description: "PointToPointTunnels holds point-to-point connectivity information for a given topology. The mapping is nodeName (i.e. srl1) -> p2p tunnel data. Both sides of the tunnel should be able to use this information to establish connectivity between Topology nodes.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type: []string{"array"},
										Items: &spec.SchemaOrArray{
											Schema: &spec.Schema{
												SchemaProps: spec.SchemaProps{
													Ref: ref("github.com/srl-labs/clabernetes/apis/v1alpha1.PointToPointTunnel"),
												},
											},
										},
									},
								},
							},
						},
					},
				},
				Required: []string{"pointToPointTunnels"},
			},
		},
		Dependencies: []string{
			"github.com/srl-labs/clabernetes/apis/v1alpha1.PointToPointTunnel"},
	}
}

func schema_srl_labs_clabernetes_apis_v1alpha1_ConnectivityStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ConnectivityStatus is the status for a Connectivity resource.",
				Type:        []string{"object"},
			},
		},
	}
}

func schema_srl_labs_clabernetes_apis_v1alpha1_Definition(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Definition holds the underlying topology definition for the Topology CR. A Topology *must* have a containerlab definition.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"containerlab": {
						SchemaProps: spec.SchemaProps{
							Description: "Containerlab holds a valid containerlab topology.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_srl_labs_clabernetes_apis_v1alpha1_Deployment(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Deployment holds configurations relevant to how clabernetes configures deployments that make up a given topology.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"resources": {
						SchemaProps: spec.SchemaProps{
							Description: "Resources is a mapping of nodeName (or \"default\") to kubernetes resource requirements -- any value set here overrides the \"global\" config resource definitions. If a key \"default\" is set, those resource values will be preferred over *all global settings* for this topology -- meaning, the \"global\" resource settings will never be looked up for this topology, and any kind/type that is *not* in this resources map will have the \"default\" resources from this mapping applied.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.ResourceRequirements"),
									},
								},
							},
						},
					},
					"scheduling": {
						SchemaProps: spec.SchemaProps{
							Description: "Scheduling holds information about how the launcher pod(s) should be configured with respect to \"scheduling\" things (affinity/node selector/tolerations).",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/srl-labs/clabernetes/apis/v1alpha1.Scheduling"),
						},
					},
					"privilegedLauncher": {
						SchemaProps: spec.SchemaProps{
							Description: "PrivilegedLauncher, when true, sets the launcher containers to privileged. Historically we tried very hard to *not* need to set privileged mode on pods, however the reality is it is much, much easier to get various network operating system images booting with this enabled, so, the default mode is to set the privileged flag on pods. Disabling this option causes clabernetes to try to run the pods for this topology in the \"not so privileged\" mode -- this basically means we mount all capabilities we think should be available, set apparmor to \"unconfined\", and mount paths like /dev/kvm and dev/net/tun. With this \"not so privileged\" mode, Nokia SRL devices and Arista cEOS devices have been able to boot on some clusters, but your mileage may vary. In short: if you don't care about having some privileged pods, just leave this alone.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"filesFromConfigMap": {
						SchemaProps: spec.SchemaProps{
							Description: "FilesFromConfigMap is a slice of FileFromConfigMap that define the configmap/path and node and path on a launcher node that the file should be mounted to. If the path is not provided the configmap is mounted in its entirety (like normal k8s things), so you *probably* want to specify the sub path unless you are sure what you're doing!",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type: []string{"array"},
										Items: &spec.SchemaOrArray{
											Schema: &spec.Schema{
												SchemaProps: spec.SchemaProps{
													Default: map[string]interface{}{},
													Ref:     ref("github.com/srl-labs/clabernetes/apis/v1alpha1.FileFromConfigMap"),
												},
											},
										},
									},
								},
							},
						},
					},
					"filesFromURL": {
						SchemaProps: spec.SchemaProps{
							Description: "FilesFromURL is a mapping of FileFromURL that define a URL at which to fetch a file, and path on a launcher node that the file should be downloaded to. This is useful for configs that are larger than the ConfigMap (etcd) 1Mb size limit.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type: []string{"array"},
										Items: &spec.SchemaOrArray{
											Schema: &spec.Schema{
												SchemaProps: spec.SchemaProps{
													Default: map[string]interface{}{},
													Ref:     ref("github.com/srl-labs/clabernetes/apis/v1alpha1.FileFromURL"),
												},
											},
										},
									},
								},
							},
						},
					},
					"persistence": {
						SchemaProps: spec.SchemaProps{
							Description: "Persistence holds configurations relating to persisting each nodes working containerlab directory.",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/srl-labs/clabernetes/apis/v1alpha1.Persistence"),
						},
					},
					"containerlabDebug": {
						SchemaProps: spec.SchemaProps{
							Description: "ContainerlabDebug sets the `--debug` flag when invoking containerlab in the launcher pods. This is disabled by default. If this value is unset, the global config value (default of \"false\") will be used.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"containerlabTimeout": {
						SchemaProps: spec.SchemaProps{
							Description: "ContainerlabTimeout sets the `--timeout` flag when invoking containerlab in the launcher pods.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"containerlabVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "ContainerlabVersion sets a custom version to use for containerlab -- when set this will cause the launcher pods to download and use this specific version of containerlab. Setting a bad version (version that doesnt exist/typo/etc.) will cause pods to fail to launch, so be careful! You never \"need\" to this as the publicly available launcher image will always be built with a (reasonably) up to date containerlab version, this setting exists in case you want to pin back to an older version for some reason or you want to be bleeding edge with some new feature (but do note that just because it exists in containerlab doesnt *necessarily* mean it will be auto-working in clabernetes!",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"launcherImage": {
						SchemaProps: spec.SchemaProps{
							Description: "LauncherImage sets the default launcher image to use when spawning launcher deployments for this Topology. This is optional, the launcher image will default to whatever is set in the global config CR.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"launcherImagePullPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "LauncherImagePullPolicy sets the default launcher image pull policy to use when spawning launcher deployments for this Topology. This is also optional and defaults to whatever is set in the global config CR (typically \"IfNotPresent\"). Note: omitempty because empty str does not satisfy enum of course.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"launcherLogLevel": {
						SchemaProps: spec.SchemaProps{
							Description: "LauncherLogLevel sets the launcher clabernetes worker log level -- this overrides whatever is set on the controllers env vars for this topology. Note: omitempty because empty str does not satisfy enum of course.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"extraEnv": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "ExtraEnv is a list of additional environment variables to set on the launcher container. The values here override any configured global config extra envs!",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.EnvVar"),
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/srl-labs/clabernetes/apis/v1alpha1.FileFromConfigMap", "github.com/srl-labs/clabernetes/apis/v1alpha1.FileFromURL", "github.com/srl-labs/clabernetes/apis/v1alpha1.Persistence", "github.com/srl-labs/clabernetes/apis/v1alpha1.Scheduling", "k8s.io/api/core/v1.EnvVar", "k8s.io/api/core/v1.ResourceRequirements"},
	}
}

func schema_srl_labs_clabernetes_apis_v1alpha1_Expose(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Expose holds configurations relevant to how clabernetes exposes a topology.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"disableExpose": {
						SchemaProps: spec.SchemaProps{
							Description: "DisableExpose indicates if exposing nodes via LoadBalancer service should be disabled, by default any mapped ports in a containerlab topology will be exposed.",
							Default:     false,
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"disableAutoExpose": {
						SchemaProps: spec.SchemaProps{
							Description: "DisableAutoExpose disables the automagic exposing of ports for a given topology. When this setting is disabled clabernetes will not auto add ports so if you want to expose (via a load balancer service) you will need to have ports outlined in your containerlab config (or equivalent for kne). When this is `false` (default), clabernetes will add and expose the following list of ports to whatever ports you have already defined:\n\n21    - tcp - ftp 22    - tcp - ssh 23    - tcp - telnet 80    - tcp - http 161   - udp - snmp 443   - tcp - https 830   - tcp - netconf (over ssh) 5000  - tcp - telnet for vrnetlab qemu host 5900  - tcp - vnc 6030  - tcp - gnmi (arista default) 9339  - tcp - gnmi/gnoi 9340  - tcp - gribi 9559  - tcp - p4rt 57400 - tcp - gnmi (nokia srl/sros default)\n\nThis setting is *ignored completely* if `DisableExpose` is true!",
							Default:     false,
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"exposeType": {
						SchemaProps: spec.SchemaProps{
							Description: "ExposeType configures the service type(s) related to exposing the topology. This is an enum that has the following valid values: - None: expose is *not* disabled, but we just don't create any services related to the pods,\n        you may want to do this if you want to tickle the pods by pod name directly for some\n        reason while not having extra services floating around.\n- ClusterIP: a clusterip service is created so you can hit that service name for the pods. - LoadBalancer: (default) creates a load balancer service so you can access your pods from\n        outside the cluster. this is/was the only behavior up to v0.2.4.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"useNodeMgmtIpv4Address": {
						SchemaProps: spec.SchemaProps{
							Description: "UseNodeMgmtIpv4Address, when set to true, the controller will look up each node’s management IPv4 address (from the `mgmt-ipv4` field in your containerlab topology) and assign that address to `Service.spec.loadBalancerIP` on the corresponding LoadBalancer Service. - Only applies if `spec.expose.exposeType` is `LoadBalancer`. - If the IP is missing or fails validation, a warning is emitted and Kubernetes\n  will allocate an IP automatically.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"useNodeMgmtIpv6Address": {
						SchemaProps: spec.SchemaProps{
							Description: "UseNodeMgmtIpv6Address, when set to true, the controller will look up each node’s management IPv6 address (from the `mgmt-ipv6` field in your containerlab topology) and assign that address to `Service.spec.loadBalancerIP` on the corresponding LoadBalancer Service. - Only applies if `spec.expose.exposeType` is `LoadBalancer`. - If the IP is missing or fails validation, a warning is emitted and Kubernetes will allocate an IP automatically.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_srl_labs_clabernetes_apis_v1alpha1_ExposedPorts(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ExposedPorts holds information about exposed ports.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"loadBalancerAddress": {
						SchemaProps: spec.SchemaProps{
							Description: "LoadBalancerAddress holds the address assigned to the load balancer exposing ports for a given node.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"tcpPorts": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "TCPPorts is a list of TCP ports exposed on the LoadBalancer service.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: 0,
										Type:    []string{"integer"},
										Format:  "int32",
									},
								},
							},
						},
					},
					"udpPorts": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "UDPPorts is a list of UDP ports exposed on the LoadBalancer service.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: 0,
										Type:    []string{"integer"},
										Format:  "int32",
									},
								},
							},
						},
					},
				},
				Required: []string{"loadBalancerAddress", "tcpPorts", "udpPorts"},
			},
		},
	}
}

func schema_srl_labs_clabernetes_apis_v1alpha1_FileFromConfigMap(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "FileFromConfigMap represents a file that you would like to mount (from a configmap) in the launcher pod for a given node.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"filePath": {
						SchemaProps: spec.SchemaProps{
							Description: "FilePath is the path to mount the file.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"configMapName": {
						SchemaProps: spec.SchemaProps{
							Description: "ConfigMapName is the name of the configmap to mount.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"configMapPath": {
						SchemaProps: spec.SchemaProps{
							Description: "ConfigMapPath is the path/key in the configmap to mount, if not specified the configmap will be mounted without a sub-path.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"mode": {
						SchemaProps: spec.SchemaProps{
							Description: "Mode sets the file permissions when mounting the configmap. Since the configmap will be read only filesystem anyway, we basically just want to expose if the file should be mounted as executable or not. So, default permissions would be 0o444 (read) and execute would be 0o555.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"filePath", "configMapName"},
			},
		},
	}
}

func schema_srl_labs_clabernetes_apis_v1alpha1_FileFromURL(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "FileFromURL represents a file that you would like to mount from a URL in the launcher pod for a given node.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"filePath": {
						SchemaProps: spec.SchemaProps{
							Description: "FilePath is the path to mount the file.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"url": {
						SchemaProps: spec.SchemaProps{
							Description: "URL is the url to fetch and mount at the provided FilePath. This URL must be a url that can be simply downloaded and dumped to disk -- meaning a normal file server type endpoint or if using GitHub or similar a \"raw\" path.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"filePath", "url"},
			},
		},
	}
}

func schema_srl_labs_clabernetes_apis_v1alpha1_ImagePull(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ImagePull holds configurations relevant to how clabernetes launcher pods handle pulling images.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"insecureRegistries": {
						SchemaProps: spec.SchemaProps{
							Description: "InsecureRegistries is a slice of strings of insecure registries to configure in the launcher pods.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"pullThroughOverride": {
						SchemaProps: spec.SchemaProps{
							Description: "PullThroughOverride allows for overriding the image pull through mode for this particular topology.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"pullSecrets": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "PullSecrets allows for providing secret(s) to use when pulling the image. This is only applicable *if* ImagePullThrough mode is auto or always. The secret is used by the launcher pod to pull the image via the cluster CRI. The secret is *not* mounted to the pod, but instead is used in conjunction with a job that spawns a pod using the specified secret. The job will kill the pod as soon as the image has been pulled -- we do this because we don't care if the pod runs, we only care that the image gets pulled on a specific node. Note that just like \"normal\" pull secrets, the secret needs to be in the namespace that the topology is in.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"dockerDaemonConfig": {
						SchemaProps: spec.SchemaProps{
							Description: "DockerDaemonConfig allows for setting the docker daemon config for all launchers in this topology. The secret *must be present in the namespace of this topology*. The secret *must* contain a key \"daemon.json\" -- as this secret will be mounted to /etc/docker and docker will be expecting the config at /etc/docker/daemon.json.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"dockerConfig": {
						SchemaProps: spec.SchemaProps{
							Description: "DockerConfig allows for setting the docker user (for root) config for all launchers in this topology. The secret *must be present in the namespace of this topology*. The secret *must* contain a key \"config.json\" -- as this secret will be mounted to /root/.docker/config.json and as such wil be utilized when doing docker-y things -- this means you can put auth things in here in the event your cluster doesn't support the preferred image pull through option.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_srl_labs_clabernetes_apis_v1alpha1_ImageRequest(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ImageRequest is an object that represents a request (from a launcher pod) to pull an image on a given kubernetes node such that the image can be \"pulled through\" into the launcher docker daemon.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/srl-labs/clabernetes/apis/v1alpha1.ImageRequestSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/srl-labs/clabernetes/apis/v1alpha1.ImageRequestStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/srl-labs/clabernetes/apis/v1alpha1.ImageRequestSpec", "github.com/srl-labs/clabernetes/apis/v1alpha1.ImageRequestStatus", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_srl_labs_clabernetes_apis_v1alpha1_ImageRequestList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ImageRequestList is a list of ImageRequest objects.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/srl-labs/clabernetes/apis/v1alpha1.ImageRequest"),
									},
								},
							},
						},
					},
				},
				Required: []string{"items"},
			},
		},
		Dependencies: []string{
			"github.com/srl-labs/clabernetes/apis/v1alpha1.ImageRequest", "k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"},
	}
}

func schema_srl_labs_clabernetes_apis_v1alpha1_ImageRequestSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ImageRequestSpec is the spec for a Config resource.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"topologyName": {
						SchemaProps: spec.SchemaProps{
							Description: "TopologyName is the name of the topology requesting the image.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"topologyNodeName": {
						SchemaProps: spec.SchemaProps{
							Description: "TopologyNodeName is the name of the node in the topology (i.e. the router name in a containerlab topology) that the image is being requested for.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"kubernetesNode": {
						SchemaProps: spec.SchemaProps{
							Description: "KubernetesNode is the node where the launcher pod is running and where the image should be pulled too.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"requestedImage": {
						SchemaProps: spec.SchemaProps{
							Description: "RequestedImage is the image that the launcher pod wants the controller to get pulled onto the specified node.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"requestedImagePullSecrets": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "RequestedImagePullSecrets is a list of configured pull secrets to set in the pull pod spec.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
				},
				Required: []string{"topologyName", "topologyNodeName", "kubernetesNode", "requestedImage"},
			},
		},
	}
}

func schema_srl_labs_clabernetes_apis_v1alpha1_ImageRequestStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ImageRequestStatus is the status for a ImageRequest resource.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"accepted": {
						SchemaProps: spec.SchemaProps{
							Description: "Accepted indicates that the ImageRequest controller has seen this image request and is going to process it. This can be useful to let the requesting pod know that \"yep, this is in the works, and i can go watch the cri images on this node now\".",
							Default:     false,
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"complete": {
						SchemaProps: spec.SchemaProps{
							Description: "Complete indicates that the ImageRequest controller has seen that the puller pod has done its job and that the image has been pulled onto the requested node.",
							Default:     false,
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
				},
				Required: []string{"accepted", "complete"},
			},
		},
	}
}

func schema_srl_labs_clabernetes_apis_v1alpha1_LinkEndpoint(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "LinkEndpoint is a simple struct to hold node/interface name info for a given link.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"nodeName": {
						SchemaProps: spec.SchemaProps{
							Description: "NodeName is the name of the node this link resides on.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"interfaceName": {
						SchemaProps: spec.SchemaProps{
							Description: "InterfaceName is the name of the interface on the node this link is on.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"nodeName", "interfaceName"},
			},
		},
	}
}

func schema_srl_labs_clabernetes_apis_v1alpha1_Persistence(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Persistence holds information about how to persist the containlerab lab directory for each node in a topology.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"enabled": {
						SchemaProps: spec.SchemaProps{
							Description: "Enabled indicates if persistence of hte containerlab lab/working directory will be placed in a mounted PVC.",
							Default:     false,
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"claimSize": {
						SchemaProps: spec.SchemaProps{
							Description: "ClaimSize is the size of the PVC for this topology -- if not provided this defaults to 5Gi. If provided, the string value must be a valid kubernetes storage requests style string. Note the claim size *cannot be made smaller* once created, but it *can* be expanded. If you need to make the claim smaller you must delete the topology (or the node from the topology) and re-add it.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"storageClassName": {
						SchemaProps: spec.SchemaProps{
							Description: "StorageClassName is the storage class to set in the PVC -- if not provided this will be left empty which will end up using your default storage class. Note that currently we assume you have (as default) or provide a dynamically provisionable storage class, hence no selector.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"enabled"},
			},
		},
	}
}

func schema_srl_labs_clabernetes_apis_v1alpha1_PointToPointTunnel(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "PointToPointTunnel holds information necessary for creating a tunnel between two interfaces on different nodes of a clabernetes Topology. This connection is established using VXLAN tunnels.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"tunnelID": {
						SchemaProps: spec.SchemaProps{
							Description: "TunnelID is the id number of the tunnel (vnid or segment id).",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"destination": {
						SchemaProps: spec.SchemaProps{
							Description: "Destination is the destination service to connect to (qualified k8s service name).",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"localNode": {
						SchemaProps: spec.SchemaProps{
							Description: "LocalNodeName is the name (in the clabernetes topology) of the local node for this side of the tunnel.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"localInterface": {
						SchemaProps: spec.SchemaProps{
							Description: "LocalInterface is the local termination of this tunnel.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"remoteNode": {
						SchemaProps: spec.SchemaProps{
							Description: "RemoteNode is the name (in the clabernetes topology) of the remote node for this side of the tunnel.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"remoteInterface": {
						SchemaProps: spec.SchemaProps{
							Description: "RemoteInterface is the remote termination interface of this tunnel -- necessary to store so can properly align tunnels (and ids!) between nodes; basically to know which tunnels are \"paired up\".",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"tunnelID", "destination", "localNode", "localInterface", "remoteNode", "remoteInterface"},
			},
		},
	}
}

func schema_srl_labs_clabernetes_apis_v1alpha1_ProbeConfiguration(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ProbeConfiguration holds information about how to probe a (containerlab) node in a Topology. If both style probes are configured, both will be used and both must succeed in order to report healthy.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"startupSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "StartupSeconds is the total amount of seconds to allow for the node to start. This defaults to ~13 minutes to hopefully account for slow to boot nodes. Note that there is also a 60 initial delay configured, so technically the default is ~14-15 minutes. Be careful with this delay as there must be time for c9s to (via whatever means) pull the image and load it into docker on the launcher and this can take a bit! Having this be bigger than you think you need is generally better since if the startup probe succeeds ever then the readiness probe takes over anyway.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"sshProbeConfiguration": {
						SchemaProps: spec.SchemaProps{
							Description: "SSHProbeConfiguration defines an SSH probe.",
							Ref:         ref("github.com/srl-labs/clabernetes/apis/v1alpha1.SSHProbeConfiguration"),
						},
					},
					"tcpProbeConfiguration": {
						SchemaProps: spec.SchemaProps{
							Description: "TCPProbeConfiguration defines a TCP probe.",
							Ref:         ref("github.com/srl-labs/clabernetes/apis/v1alpha1.TCPProbeConfiguration"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/srl-labs/clabernetes/apis/v1alpha1.SSHProbeConfiguration", "github.com/srl-labs/clabernetes/apis/v1alpha1.TCPProbeConfiguration"},
	}
}

func schema_srl_labs_clabernetes_apis_v1alpha1_ReconcileHashes(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ReconcileHashes holds hashes of the last recorded reconciliation -- these are used to know if things have changed between the last and current reconciliation.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"config": {
						SchemaProps: spec.SchemaProps{
							Description: "Config is the last stored hash of the rendered config(s) -- that is, the map of \"sub topologies\" representing the overall Topology.Spec.Definition.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"exposedPorts": {
						SchemaProps: spec.SchemaProps{
							Description: "ExposedPorts is the last stored hash of the exposed ports mapping for this Topology. Note that while we obviously care about the exposed ports on a *per node basis*, we don't need to track that here -- this is here strictly to track differences in the load balancer service -- the actual sub-topologies (or sub-configs) effectively track the expose port status per node.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"filesFromURL": {
						SchemaProps: spec.SchemaProps{
							Description: "FilesFromURL is the hash of the last stored mapping of files from URL (to node mapping). Note that this is tracked on a *per node basis* because the URL of a file could be updated without any change to the actual config/topology (or sub-config/sub-topology); as such we need to explicitly track this per node to know when a node needs to be restarted such that the new URL is \"picked up\" by the node/launcher.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"imagePullSecrets": {
						SchemaProps: spec.SchemaProps{
							Description: "ImagePullSecrets is the hash of hte last stored image pull secrets for this Topology.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"config", "exposedPorts", "filesFromURL", "imagePullSecrets"},
			},
		},
	}
}

func schema_srl_labs_clabernetes_apis_v1alpha1_SSHProbeConfiguration(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "SSHProbeConfiguration defines a \"ssh\" probe -- the ssh probe just connects using standard go crypto ssh setup and reports true if auth is successful, it does no further checking. The probe is executed by the launcher and the result is placed into /clabernetes/.nodestatus so the k8s probe can pick it up and reflect the status.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"username": {
						SchemaProps: spec.SchemaProps{
							Description: "Username is the username to use for auth.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"password": {
						SchemaProps: spec.SchemaProps{
							Description: "Password is the password to use for auth.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"port": {
						SchemaProps: spec.SchemaProps{
							Description: "Port is an optional override (of course default is 22).",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
				Required: []string{"username", "password"},
			},
		},
	}
}

func schema_srl_labs_clabernetes_apis_v1alpha1_Scheduling(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Scheduling holds information about how the launcher pod(s) should be configured with respect to \"scheduling\" things (affinity/node selector/tolerations).",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"nodeSelector": {
						SchemaProps: spec.SchemaProps{
							Description: "NodeSelector sets the node selector that will be configured on all launcher pods for this Topology.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"tolerations": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Tolerations is a list of Tolerations that will be set on the launcher pod spec.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.Toleration"),
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/api/core/v1.Toleration"},
	}
}

func schema_srl_labs_clabernetes_apis_v1alpha1_StatusProbes(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "StatusProbes holds details about if the status probes are enabled and if so how they should be handled.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"enabled": {
						SchemaProps: spec.SchemaProps{
							Description: "Enabled sets the status probes to enabled (or obviously disabled). Note that if the probes are enabled and the health condition fails due to configuring the node the cluster will restart the node. So, if you plan on being destructive with the node config (probably because you will have exec'd onto the node) then you may want to disable this!",
							Default:     false,
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"excludedNodes": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "ExcludedNodes is a set of nodes to be excluded from status probe checking. It may be desirable to exclude some node(s) from status checking due to them not having an easy way for clabernetes to check the state of the node. The node names here should match the name of the nodes in the containerlab sub-topology.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"nodeProbeConfigurations": {
						SchemaProps: spec.SchemaProps{
							Description: "NodeProbeConfigurations is a map of node specific probe configurations -- if you only need a simple ssh or tcp connect style setup that works on all node types in the topology you can ignore this and just configure ProbeConfiguration.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/srl-labs/clabernetes/apis/v1alpha1.ProbeConfiguration"),
									},
								},
							},
						},
					},
					"probeConfiguration": {
						SchemaProps: spec.SchemaProps{
							Description: "ProbeConfiguration is the default probe configuration for the Topology.",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/srl-labs/clabernetes/apis/v1alpha1.ProbeConfiguration"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/srl-labs/clabernetes/apis/v1alpha1.ProbeConfiguration"},
	}
}

func schema_srl_labs_clabernetes_apis_v1alpha1_TCPProbeConfiguration(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "TCPProbeConfiguration defines a \"tcp\" probe. The probe is executed by the launcher and the result is placed into /clabernetes/.nodestatus so the k8s probe can pick it up and reflect the status.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"port": {
						SchemaProps: spec.SchemaProps{
							Description: "Port defines the port to try to open a TCP connection to. When using TCP probe setup this connection happens inside the launcher rather than the \"normal\" k8s style probes. This style probe behaves like a k8s style probe though in that it is \"successful\" whenever a TCP connection to this port can be opened successfully.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
				Required: []string{"port"},
			},
		},
	}
}

func schema_srl_labs_clabernetes_apis_v1alpha1_Topology(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Topology is an object that holds information about a clabernetes Topology -- that is, a valid topology file (ex: containerlab topology), and any associated configurations.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/srl-labs/clabernetes/apis/v1alpha1.TopologySpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/srl-labs/clabernetes/apis/v1alpha1.TopologyStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/srl-labs/clabernetes/apis/v1alpha1.TopologySpec", "github.com/srl-labs/clabernetes/apis/v1alpha1.TopologyStatus", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_srl_labs_clabernetes_apis_v1alpha1_TopologyList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "TopologyList is a list of Topology objects.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/srl-labs/clabernetes/apis/v1alpha1.Topology"),
									},
								},
							},
						},
					},
				},
				Required: []string{"items"},
			},
		},
		Dependencies: []string{
			"github.com/srl-labs/clabernetes/apis/v1alpha1.Topology", "k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"},
	}
}

func schema_srl_labs_clabernetes_apis_v1alpha1_TopologySpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "TopologySpec is the spec for a Topology resource.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"definition": {
						SchemaProps: spec.SchemaProps{
							Description: "Definition defines the actual set of nodes (network ones, not k8s ones!) that this Topology CR represents. Historically, and probably most often, this means Topology holds a \"normal\" containerlab topology file that will be \"clabernetsified\", however this could also be a \"kne\" config, or perhaps others in the future.",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/srl-labs/clabernetes/apis/v1alpha1.Definition"),
						},
					},
					"expose": {
						SchemaProps: spec.SchemaProps{
							Description: "Expose holds configurations relevant to how clabernetes exposes a topology.",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/srl-labs/clabernetes/apis/v1alpha1.Expose"),
						},
					},
					"deployment": {
						SchemaProps: spec.SchemaProps{
							Description: "Deployment holds configurations relevant to how clabernetes configures deployments that make up a given topology.",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/srl-labs/clabernetes/apis/v1alpha1.Deployment"),
						},
					},
					"statusProbes": {
						SchemaProps: spec.SchemaProps{
							Description: "StatusProbes holds the configurations relevant to how clabernetes and the launcher handle checking and reporting the containerlab node status",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/srl-labs/clabernetes/apis/v1alpha1.StatusProbes"),
						},
					},
					"imagePull": {
						SchemaProps: spec.SchemaProps{
							Description: "ImagePull holds configurations relevant to how clabernetes launcher pods handle pulling images.",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/srl-labs/clabernetes/apis/v1alpha1.ImagePull"),
						},
					},
					"naming": {
						SchemaProps: spec.SchemaProps{
							Description: "Naming tells the clabernetes controller how it should name resources it creates -- that is whether it should include the containerlab topology name as a prefix on resources spawned from this Topology or not; this includes the actual (containerlab) node Deployment(s), as well as the Service(s) for the Topology. This setting has three modes; \"prefixed\" -- which of course includes the containerlab topology name as a prefix, \"non-prefixed\" which does *not* include the containerlab topology name as a prefix, and \"global\" which defers to the global config setting for this (which defaults to \"prefixed\"). \"non-prefixed\" mode should only be enabled when/if Topologies are deployed in their own namespace -- the reason for this is simple: if two Topologies exist in the same namespace with a (containerlab) node named \"my-router\" there will be a conflicting Deployment and Services for the \"my-router\" (containerlab) node. Note that this field is immutable! If you want to change its value you need to delete the Topology and re-create it.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"connectivity": {
						SchemaProps: spec.SchemaProps{
							Description: "Connectivity defines the type of connectivity to use between nodes in the topology. The default behavior is to use vxlan tunnels.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"definition", "naming"},
			},
		},
		Dependencies: []string{
			"github.com/srl-labs/clabernetes/apis/v1alpha1.Definition", "github.com/srl-labs/clabernetes/apis/v1alpha1.Deployment", "github.com/srl-labs/clabernetes/apis/v1alpha1.Expose", "github.com/srl-labs/clabernetes/apis/v1alpha1.ImagePull", "github.com/srl-labs/clabernetes/apis/v1alpha1.StatusProbes"},
	}
}

func schema_srl_labs_clabernetes_apis_v1alpha1_TopologyStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "TopologyStatus is the status for a Topology resource.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is the topology kind this CR represents -- for example \"containerlab\".",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"removeTopologyPrefix": {
						SchemaProps: spec.SchemaProps{
							Description: "RemoveTopologyPrefix holds the \"resolved\" value of the RemoveTopologyPrefix field -- that is if it is unset (nil) when a Topology is created, the controller will use the default global config value (false); if the field is non-nil, this status field will hold the non-nil value.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"reconcileHashes": {
						SchemaProps: spec.SchemaProps{
							Description: "ReconcileHashes holds the hashes form the last reconciliation run.",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/srl-labs/clabernetes/apis/v1alpha1.ReconcileHashes"),
						},
					},
					"configs": {
						SchemaProps: spec.SchemaProps{
							Description: "Configs is a map of node name -> containerlab config -- in other words, this is the original Topology.Spec.Definition converted to containerlab \"sub-topologies\" The actual \"sub-topologies\"/\"sub-configs\" are stored as a string -- this is the actual containerlab topology that gets mounted in the launcher pod.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"exposedPorts": {
						SchemaProps: spec.SchemaProps{
							Description: "ExposedPorts holds a map of (containerlab not k8s!) nodes and their exposed ports (via load balancer).",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("github.com/srl-labs/clabernetes/apis/v1alpha1.ExposedPorts"),
									},
								},
							},
						},
					},
					"nodeReadiness": {
						SchemaProps: spec.SchemaProps{
							Description: "NodeReadiness is a map of nodename to readiness status. The readiness status is as reported by the k8s startup/readiness probe (which is in turn managed by the status probe configuration of the topology). The possible values are \"notready\" and \"ready\", \"unknown\".",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"topologyReady": {
						SchemaProps: spec.SchemaProps{
							Description: "TopologyReady indicates if all nodes in the topology have reported ready. This is duplicated from the conditions so we can easily snag it for print columns!",
							Default:     false,
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"conditions": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Conditions is a list of conditions for the topology custom resource.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.Condition"),
									},
								},
							},
						},
					},
				},
				Required: []string{"kind", "removeTopologyPrefix", "reconcileHashes", "configs", "exposedPorts", "nodeReadiness", "topologyReady", "conditions"},
			},
		},
		Dependencies: []string{
			"github.com/srl-labs/clabernetes/apis/v1alpha1.ExposedPorts", "github.com/srl-labs/clabernetes/apis/v1alpha1.ReconcileHashes", "k8s.io/apimachinery/pkg/apis/meta/v1.Condition"},
	}
}
